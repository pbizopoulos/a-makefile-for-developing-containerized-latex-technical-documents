\documentclass[journal]{IEEEtran}
\usepackage[boxed]{algorithm2e}
\usepackage[nopdftrailerid=true]{pdfprivacy}

\begin{document}

\title{Portable Development Methodology}

\author{Paschalis~Bizopoulos
\thanks{P. Bizopoulos is an Independent Researcher, Thessaloniki, Greece e-mail: pbizop@gmail.com}}

\maketitle

\begin{abstract}
	This paper proposes a portable development methodology.
	We release open source repositories of the examples use cases of this.
\end{abstract}

\section{Introduction}
Widespread software development practices like agile~\cite{abrahamsson2017agile} are not concrete enough thus multiple versions of it exist in software development.
This non-portability of software development practices is a lost potential in reducing software development time.

In this paper we present the design and implementation of the Makefile for python and tex for document generation and then the Makefile for website creation.

\section{Make}
Make has existed for decades and has passed the test of time, while the container technology was standardized with the Open Container Initiative and there exist alternatives such as Podman that could be used as drop-in replacements for Docker.
Moreover the Makefile can be combined with any version control system, container registry provider and text editor thus preventing `app/vendor lock-in' situations.

Use cases of the Makefile include:
\begin{itemize}
	\item regression testing and debugging, to ensure that changes to \texttt{code} do not alter the generated data,
	\item portable development environment across multiple \texttt{developers},
	\item portable development environment across time.
\end{itemize}

\section{Directory structure}
The following directory structure is the superset of files and directories that the \texttt{python/} directory can consist.
The interface of the Makefile is a subset of the GNU standard targets:
\begin{itemize}
	\item \texttt{.dockerignore}: Consists of:
		\begin{itemize}
			\item * (every file/directory)
			\item except files needed for environment creation (e.g.\ \texttt{pyproject.toml})
		\end{itemize}
	\item \texttt{.gitignore}: Consists of:
		\begin{itemize}
			\item the temporary directory \texttt{tmp/} and
			\item the environmental variable file \texttt{.env}.
		\end{itemize}
	\item \texttt{Dockerfile}: Rarely editable. The developer edits:
		\begin{itemize}
			\item the FROM image and
			\item whether other apt-get installations are done.
		\end{itemize}
	\item \texttt{Makefile}: Non-editable. Properties~\cite{stallman1992gnu}:
		\begin{itemize}
			\item It should be POSIX-compliant and use POSIX utilities~\cite{lewine1991posix}.
			\item The \texttt{all} target should generate data saved in \texttt{tmp/}.
			\item The \texttt{check} target should check all \texttt{code}. It should also check and disallow any additional files or directories besides the ones defined here.
			\item The \texttt{clean} target should delete \texttt{tmp/}.
			\item It should support a \texttt{STAGING} environment variable which can be used for debugging purposes and having fast development iteration.
			\item It should create all files and directories from the structure if they do not already exist.
		\end{itemize}
	\item \texttt{main.py}: Frequently editable. The developer writes \texttt{code} in here that generates data saved in \texttt{tmp/}.
	\item \texttt{prm/}: The developer can place here all the files/directories for which generation from code is infeasible. This should be as small as possible.
	\item \texttt{pyproject.toml}: Rarely editable. The developer edits:
		\begin{itemize}
			\item the dependencies and
			\item the version of the dependencies
		\end{itemize}
	\item \texttt{tmp/}: Data generated by \texttt{main.py} are saved here.
\end{itemize}

\section{Workflow}

\begin{algorithm}
	\KwData{User requirement}
	\If{user requirement is unimportant}{
		\Return{}
	}
	\If{it can be solved without software}{
		\Return{}
	}
	\If{a package already exists}{
		Introduce the package as a dependency in the relevant main.py\;
		\Return{}
	}
	\If{a relevant repository exists}{
		Make repository compatible with stack/method\;
		\Return{}
	}
	\If{it can be programmed within a relevant main.py}{
		Program it in a relevant main.py\;
		\Return{}
	}
	\If{it can be programmed as a dependency/dependent of another directory}{
		Create a new dependent directory\;
		\Return{}
	}
	Create a new repository\;
	\Return{}
	\caption{Workflow}
\end{algorithm}

\bibliographystyle{IEEEtran}
\bibliography{ms.bib}

\end{document}
