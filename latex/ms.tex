\documentclass[journal]{IEEEtran}
\usepackage{dirtree}
\usepackage[boxed]{algorithm2e}
\usepackage[nopdftrailerid=true]{pdfprivacy}

\begin{document}

\title{Portable Development Methodology}

\author{Paschalis~Bizopoulos
\thanks{P. Bizopoulos is an Independent Researcher, Thessaloniki, Greece e-mail: pbizop@gmail.com}}

\maketitle

\begin{abstract}
	This paper proposes a portable development methodology.
	We release open source repositories of the examples use cases of this.
\end{abstract}

\section{Introduction}
Widespread software development practices like agile~\cite{abrahamsson2017agile} are not concrete enough thus multiple versions of it exist in software development.
This non-portability of software development practices is a lost potential in reducing software development time.

In this paper we present the design and implementation of the Makefile for python and tex for document generation and then the Makefile for website creation.

\section{Make}
Make has existed for decades and has passed the test of time, while the container technology was standardized with the Open Container Initiative and there exist alternatives such as Podman that could be used as drop-in replacements for Docker.
Moreover the Makefile can be combined with any version control system, container registry provider and text editor thus preventing `app/vendor lock-in' situations.

Use cases of the Makefile include:
\begin{itemize}
	\item regression testing and debugging, to ensure that changes to \texttt{code} do not alter the \texttt{artifacts},
	\item portable development environment across multiple \texttt{developers},
	\item portable development environment across time.
\end{itemize}

Makes use of pre-existing standards:
\begin{itemize}
	\item GNU standard targets for Makefile~\cite{stallman1992gnu}
	\item POSIX Utilities and Shell~\cite{lewine1991posix}
\end{itemize}

We use Makefile to create the isolated environment (container) by creating all required files if not already present and to make sure that subsequent changes to the requirements update the environment.

The interface of the Makefile is a subset of the GNU standard targets:
\begin{verbatim}
make           # execute code 
make STAGING=1 # execute staging code 
make check     # check code
make clean     # remove tmp/
\end{verbatim}

With the \texttt{STAGING} environment variable which can be used for debugging purposes and having fast development iteration.

\section{Folder structure}
\dirtree{%
.0 python.
.1 \texttt{.dockerignore}.
.1 \texttt{.gitignore}.
.1 Dockerfile.
.1 Makefile.
.1 main.py.
.1 prm/.
.1 pyproject.toml.
.1 tmp/.
}

\section{Workflow}

\begin{algorithm}
	\KwData{User requirement}
	\If{user requirement is unimportant}{
		\Return{}
	}
	\If{it can be solved without software}{
		\Return{}
	}
	\If{a package already exists}{
		Introduce the package as a dependency in the relevant main.py\;
		\Return{}
	}
	\If{a relevant repository exists}{
		Make repository compatible with stack/method\;
		\Return{}
	}
	\If{it can be programmed within a relevant main.py}{
		Program it in a relevant main.py\;
		\Return{}
	}
	\If{it can be programmed as a dependency/dependent of another directory}{
		Create a new dependent directory\;
		\Return{}
	}
	Create a new repository\;
	\Return{}
	\caption{Workflow}
\end{algorithm}

\bibliographystyle{IEEEtran}
\bibliography{ms.bib}

\end{document}
