\documentclass[journal]{IEEEtran}
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage[nopdftrailerid=true]{pdfprivacy}
\usepackage{booktabs}
\usepackage{datatool}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{trees}
\usetikzlibrary{fit}
\usetikzlibrary{backgrounds}
\usepackage{hyperref}

\begin{document}
\DTLloaddb{keys-values}{python/bin/keys-values.csv}

\title{Principle of least action as a software development method}

\author{Paschalis~Bizopoulos
\thanks{P. Bizopoulos is an Independent Researcher, Thessaloniki, Greece e-mail: pbizopoulos@protonmail.com}}

\maketitle

\begin{abstract}
	We propose principle of least action as a software development method.
	We release open source repositories of the examples use cases of this method.
\end{abstract}

\section{Introduction}
Action is ...
Principle of least action is ...

\section{Action and software development}
The principle of least action can be used throughout all decision of a software project.

a. characteristics of the user (e.g. technical capabilities)
b. characteristics of the user environment (e.g. Operating system)
c. characteristics of the developer (e.g. technical capabilities)
choose the technologies that allow the developer to minimize the development and user path length through space (other computers) and time (in the future)
d. characteristics of the developer environment (e.g. Operating system)
different stakeholders calculate different actions. the developer sees the path that corresponds to the development procedure while the user sees the path that corresponds the usage of the binary
if the benefit is greater than the cost then it is implemented
moreover the cost and benefits are relative to the user and developer respectively
software development should take in consideration stability both for the user and the developer across two axis: space (other machines) and time
stability not only applies the same program use but also to other programs
the benefit of achieving a target is balanced with the cost of the time required to achieve it
the minimal action principle results in the unix philosophy: Programs should do one thing and one thing only. From that sense a window manager should only be responsible for managing windows and not workspaces, tags etc
the central concept of the paper is translating the idea of action and the principle of minimal action to software development as a specification and then show the implementation that uses Makefile+containers
present the design and implementation of fswm, then the Makefile for python and tex for document generation and then the Makefile for website creation
creating a program (the target) sometimes requires creating tools (as intermediate targets) that can be use to reduce the development time (the path length to the target)
it is not just about minimizing time or being completely accurate in satisfying the requirements. A combination of these is required
the path to the target is the source code which can be evaluated with make check. The path should fulfill the needs of the developers and can change
the target is the the final program which can be reached with make. The target should fulfill the needs of the users and can change
both users and developers want to reduce their relative action. Balance is achieved at a point

\section{Development environment/tools}
Mention install-archlinux.
Mention vim etc.

\section{The Makefile}
The principle of least action has been applied in the following aspects of the Makefile:
\begin{itemize}
	\item this
	\item that
\end{itemize}

although we could have a target regarding downloading external data this makes the Makefile non-portable for other projects thus this action needs to be done within the code
consistency across time from the developer perspective means that the technology used to program it will be available in the future
consistency across time from the user perspective practically means that the program should be finished from the point of view of features and only bug fixes might be developed
makes use of pre-existing standards: GNU standard for Makefile conventions and POSIX for the use of UNIX tools
the portability of the Makefile is achieved by using the mandatory UNIX utilities also mentioned by the GNU standard with the exception of docker or npm where needed
there is an inverse relationship between consistency and configurability
think about that I have used subsets of standards
time includes user interation to reach the target and total development time (including maintainance)
users care about the program, developers care about the code
we define a target of reducing the time required to create and navigate windows in a computing environment
we use Makefile to create the isolated environment (container) by bootstraping all required files if not already present and to make sure that subsequent changes to the requirements update the environment. The DAG should be as project agnostic as possible thus sentinel files are used
we use these specific targets for the Makefile (all, check, clean, help) because the first three are standard targets recommended by GNU standard targets and the fourth one is used in the linux kernel

\section{Variable naming}
think prime-modifier-class naming scheme and how it relates to the action-as-information

\section{Example use case: window manager}
an extreme example of configurable window managers is `ricing' where the window manager is configured mostly for form and not function
fswm targets users with high technical capabilities (therefore no visual indication is needed regarding which window they are in every time etc.)
if keyboard portability is not so important then keycodes are hardcoded for the specific user environment
moreover a window manager should open windows only in full screen
the concept of tiling window managers is oriented towards multitasking
the key shortcuts of a window manager should be predictable by resembling as close as possible most other window managers and development environemnts
the need to be portable across different keyboards demands the use of an additional requirement (xcb-util-keysyms)
the set of functionalities that should be integrated to a window manager are: Enter next/previous window and open program in new window
the windows could be easily represented as a cyclic doubly linked list
thus C89 was chosen for optimal portability and xcb as the main library
an additional advantage of non-configurability is that the program is ready to be used when installed

\section{Example use case: technical document}
This section provides a use case of the Makefile and also serves as a manual for developing using this method.
We train, validate and test MobilenetV2 neural networks~\cite{sandler2018mobilenetv2} in PyTorch, on MNIST~\cite{lecun2010mnist}, FashionMNIST~\cite{xiao2017fashion}, KMNIST~\cite{clanuwat2018deep} and QMNIST~\cite{yadav2019cold}.
We use the default train, validation and test datasets and compare the use of ReLU, ReLU6\cite{dahl2013improving} and SiLU\cite{elfwing2018sigmoid} activation functions in the MobilenetV2 model.

Making use of the \textit{datatool} package the values of the following variables are not directly referred in the main \textit{.tex} file but they are instead read by an intermediate \textit{.tex} file created by the \textit{results code}: the number of epochs is $\DTLfetch{keys-values}{key}{epochs-num}{value}$, the batch size is $\DTLfetch{keys-values}{key}{batch-size}{value}$ and the learning rate for SGD is $\DTLfetch{keys-values}{key}{lr}{value}$.
Additionally, making use of random seed setting we consistenly get the same figures as shown in Fig.\ref{fig:loss} and Fig.\ref{fig:kernels}.
We also use the \textit{pandas.DataFrame.to\_latex} command which automatically converts a dataframe table to a \LaTeX\ table (as shown in Table~\ref{table:table}):

\begin{figure}[!t]
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/MNIST-loss.pdf}}
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/FashionMNIST-loss.pdf}}
	\\
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/KMNIST-loss.pdf}}
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/QMNIST-loss.pdf}}
	\caption{Comparison of the train and validation loss of MobilenetV2 with ReLU, ReLU6 and SiLU for all datasets.}\label{fig:loss}
\end{figure}

\begin{figure}[!t]
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/MNIST-ReLU-kernels.pdf}}
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/FashionMNIST-ReLU-kernels.pdf}}
	\\
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/KMNIST-ReLU-kernels.pdf}}
	\subfloat{\includegraphics[width=0.5\columnwidth]{python/bin/QMNIST-ReLU-kernels.pdf}}
	\caption{The first 25 kernels of the first convolutional layer of MobilenetV2 with ReLU for MNIST (upper-left), FashionMNIST (upper-right), KMNIST (lower-left) and QMNIST (lower-right).}\label{fig:kernels}
\end{figure}

\begin{table}[ht]
	\centering
	\caption{MobilenetV2 test dataset accuracies.}\label{table:table}
	\setlength\tabcolsep{4pt}
	\input{python/bin/metrics.tex}
\end{table}

\section{About the use of Make}
The proposed Makefile is based on plain text file editing and can be used with any operating system that supports containers and Make.
Make has existed for decades and has passed the test of time, while the container technology was standardized with the Open Container Initiative and there exist alternatives such as Podman that could be used as drop-in replacements for Docker.
Moreover the Makefile can be combined with any version control system, container registry provider and text editor thus preventing `app/vendor lock-in' situations.

Use cases of the Makefile include:
\begin{itemize}
	\item regression testing and debugging, to ensure that changes to \textit{code} do not alter \textit{results},
	\item common development environment across multiple \textit{authors},
	\item coauthors, reviewers, journal editors or other researchers can easily reproduce the \textit{document} with few requirements.
\end{itemize}

\section*{Conclusion}

\bibliographystyle{IEEEtran}
\bibliography{ms.bib}

\end{document}
