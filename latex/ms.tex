\documentclass[journal]{IEEEtran}
\usepackage{dirtree}
\usepackage[boxed]{algorithm2e}
\usepackage[nopdftrailerid=true]{pdfprivacy}
\usepackage{hyperref}

\begin{document}

\title{Development Methodology}

\author{Paschalis~Bizopoulos
\thanks{P. Bizopoulos is an Independent Researcher, Thessaloniki, Greece e-mail: pbizop@gmail.com}}

\maketitle

\begin{abstract}
	This paper proposes a development methodology and also presents example use cases.
\end{abstract}

\section{Introduction}
Software development practices like agile~\cite{abrahamsson2017agile} are not concrete enough, thus multiple subversions of each of them exist in software development.
Loosely defined practices introduce non-portability issues between developers and through time, increasing development costs.

In this paper we present a development methodology which is concrete enough to be portable and abstract enough to be of general use.
We also present example use cases for python and tex document generation and website creation.

\section{Requirements}
POSIX utilities and shell are the base of any Unix system today.
However, they are not enough to cover modern user/developer requirements, such as machine learning and web applications.

Containers such as Docker, can be used to create isolated environments.
Containers were standardized with the Open Container Initiative\footnote{\url{https://opencontainers.org/}} and there exist alternatives such as Podman that could be used as drop-in replacements for Docker.

\section{Directory structure}
\dirtree{.0 python/|docs/|latex/.
.1 \texttt{.dockerignore}.
.1 \texttt{.gitignore}.
.1 Dockerfile.
.1 Makefile.
.1 main.py|index.html|ms.tex.
.1 prm/.
.1 pyproject.toml|package.json.
.1 tmp/.
}

The following directory structure is the superset of files and directories that the \texttt{python/} directory can consist.
The interface of the Makefile is a subset of the GNU standard targets.
File and directory name whitelisting is enforced with the target of having one file per `technology'.
\begin{itemize}
	\item \texttt{.dockerignore}: Consists of:
		\begin{itemize}
			\item * (every file/directory)
			\item except files needed for environment creation (e.g.\ \texttt{pyproject.toml})
		\end{itemize}
	\item \texttt{.gitignore}: Consists of:
		\begin{itemize}
			\item the temporary directory \texttt{tmp/} and
			\item the environmental variable file \texttt{.env}.
		\end{itemize}
	\item \texttt{Dockerfile}: Rarely editable. The developer edits:
		\begin{itemize}
			\item the FROM image and
			\item whether other apt-get installations are done.
		\end{itemize}
	\item \texttt{Makefile}: Non-editable. Properties~\cite{stallman1992gnu}:
		\begin{itemize}
			\item It should be POSIX-compliant and use POSIX utilities~\cite{lewine1991posix}.
			\item The \texttt{all} target should generate data saved in \texttt{tmp/}.
			\item The \texttt{check} target should check all \texttt{code}. It should also check and disallow any additional files or directories besides the ones defined here.
			\item The \texttt{clean} target should delete \texttt{tmp/}.
			\item It should support a \texttt{STAGING} environment variable which can be used for debugging purposes and having fast development iteration.
			\item It should create all files and directories from the structure if they do not already exist.
		\end{itemize}
	\item \texttt{main.py}: Frequently editable. The developer writes \texttt{code} in here that generates data saved in \texttt{tmp/}.
	\item \texttt{prm/}: The developer can place here all the files/directories for which generation from code is infeasible. It is a practical `backdoor' out of the file/directory name whitelisting of the Makefile. The contents of this directory should be as few as possible.
	\item \texttt{pyproject.toml}: Rarely editable. The developer edits:
		\begin{itemize}
			\item the dependencies and
			\item the version of the dependencies
		\end{itemize}
	\item \texttt{tmp/}: Data generated by \texttt{main.py} are saved here.
\end{itemize}

\section{Workflows}

\begin{algorithm}
	\KwData{New user/developer requirement}
	\If{requirement is unimportant}{
		\Return{}
	}
	\If{it can be solved without software}{
		\Return{}
	}
	\If{a package already exists}{
		Introduce the package as a dependency in the relevant main.py\;
		\Return{}
	}
	\If{a relevant repository exists}{
		Make repository compatible with stack/method\;
		\Return{}
	}
	\If{it can be programmed within a relevant main.py}{
		Program it in a relevant main.py\;
		\Return{}
	}
	\If{it can be programmed as a dependency/dependent of another directory}{
		Create a new dependent directory\;
		\Return{}
	}
	Create a new repository\;
	\Return{}
	\caption{Workflow for new user/developer requirement}
\end{algorithm}

\bibliographystyle{IEEEtran}
\bibliography{ms.bib}

\end{document}
